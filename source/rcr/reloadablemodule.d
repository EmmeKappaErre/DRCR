module rcr.reloadablemodule;

import rcr.atomicbool;
import rcr.log;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ReloadableModule
{
public:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    alias Handle = void*;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    enum ReloadFlag
    {
        eCleanCompileAndReload,
        eCleanCompileAndNoReload,
        eCompileAndReload,
        eCompileNoReload,
        eNoCompileAndReload,
    };

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    this()
    {
        m_reloading = false;
        m_needsReloadProcessing = false;
        m_log = new ConsoleLog();
        m_onDLLLoadCallback = null;
    }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Add a request for reloading the module
    bool requestReload(ReloadFlag flag = ReloadFlag.eCompileAndReload)
	{
		if (m_reloading)
		{
            m_log.error("Failed to start a reload as a reload is already in progress.");
			return false;
		}

        bool result = true;
        bool needCompiling = __needsCompiling(flag);
        bool needsReloading = __needsReloading(flag);
		m_reloading = needCompiling | needsReloading;

        if(needCompiling)
        {
			if (!__compileDLL(flag))
			{
                m_log.error("Failed to compile the required DLL; check that all the paths are correct and retry.");
				needsReloading = false;
                result = false;
			}
        }
		if (needsReloading)
		{
			m_needsReloadProcessing = true;
		}
		else
		{
			m_needsReloadProcessing = false;
			m_reloading = false;
		}

		return result;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Process a pending request for reload
    abstract void processReload();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Returns true once any pending request is being processed
	bool isReloading() const
	{
		return cast(bool) m_reloading;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	abstract Handle handle();

protected:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	abstract bool __compileDLL(ReloadFlag flag);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	AtomicBool	            m_reloading;
	AtomicBool	            m_needsReloadProcessing;
    ILog                    m_log;
    void delegate(Handle)   m_onDLLLoadCallback;

private:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	static bool __needsCompiling(ReloadFlag flag)
	{
		return flag == ReloadFlag.eCleanCompileAndReload || flag == ReloadFlag.eCleanCompileAndNoReload || 
			   flag == ReloadFlag.eCompileAndReload || flag == ReloadFlag.eCompileNoReload;
	}

	static bool __needsReloading(ReloadFlag flag)
	{
		return flag == ReloadFlag.eCleanCompileAndReload || flag == ReloadFlag.eCompileAndReload || 
			   flag == ReloadFlag.eNoCompileAndReload;
	}
}